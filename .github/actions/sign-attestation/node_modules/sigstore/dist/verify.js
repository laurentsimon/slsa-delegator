"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Verifier = void 0;
const error_1 = require("./error");
const verify_1 = require("./tlog/verify");
const util_1 = require("./util");
class Verifier {
    constructor(options) {
        this.tlog = options.tlog;
        this.tlogKeys = options.tlogKeys;
        this.getExternalPublicKey =
            options.getPublicKey || (() => Promise.resolve(undefined));
    }
    async verifyOffline(bundle, data) {
        const publicKey = await this.getPublicKey(bundle);
        verifyArtifactSignature(bundle, publicKey, data);
        (0, verify_1.verifyTLogEntries)(bundle, this.tlogKeys);
    }
    async getPublicKey(bundle) {
        var _a, _b;
        let publicKey;
        switch ((_b = (_a = bundle.verificationMaterial) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.$case) {
            case 'x509CertificateChain':
                publicKey = getSigningCertificate(bundle.verificationMaterial.content.x509CertificateChain);
                break;
            case 'publicKey':
                publicKey = await this.getExternalPublicKey(bundle.verificationMaterial.content.publicKey.hint);
                break;
            default:
                throw new error_1.InvalidBundleError('no verification material found');
        }
        if (!publicKey) {
            throw new error_1.VerificationError('no public key found for signature verification');
        }
        return publicKey;
    }
}
exports.Verifier = Verifier;
// Performs bundle signature verification. Determines the type of the bundle
// content and delegates to the appropriate signature verification function.
function verifyArtifactSignature(bundle, publicKey, data) {
    var _a;
    switch ((_a = bundle.content) === null || _a === void 0 ? void 0 : _a.$case) {
        case 'messageSignature':
            if (!data) {
                throw new error_1.VerificationError('no data provided for message signature verification');
            }
            verifyMessageSignature(bundle.content.messageSignature, publicKey, data);
            break;
        case 'dsseEnvelope':
            verifyDSSESignature(bundle.content.dsseEnvelope, publicKey);
            break;
        default:
            throw new error_1.InvalidBundleError('no content found');
    }
}
// Performs signature verification for bundle containing a message signature.
// Verifies the signature found in the bundle against the provided data.
function verifyMessageSignature(messageSignature, publicKey, data) {
    // Extract signature for message
    const signature = messageSignature.signature;
    if (!util_1.crypto.verifyBlob(data, publicKey, signature)) {
        throw new error_1.VerificationError('artifact signature verification failed');
    }
}
// Performs signature verification for bundle containing a DSSE envelope.
// Calculates the PAE for the DSSE envelope and verifies it against the
// signature in the envelope.
function verifyDSSESignature(envelope, publicKey) {
    // Construct payload over which the signature was originally created
    const { payloadType, payload } = envelope;
    const data = util_1.dsse.preAuthEncoding(payloadType, payload);
    // Extract signature from DSSE envelope
    if (envelope.signatures.length < 1) {
        throw new error_1.InvalidBundleError('no signatures found in DSSE envelope');
    }
    // Only support a single signature in DSSE
    const signature = envelope.signatures[0].sig;
    if (!util_1.crypto.verifyBlob(data, publicKey, signature)) {
        throw new error_1.VerificationError('artifact signature verification failed');
    }
}
// Extracts the signing certificate from the bundle and formats it as a
// PEM-encoded string.
function getSigningCertificate(chain) {
    const signingCert = chain.certificates[0];
    return signingCert ? util_1.pem.fromDER(signingCert.rawBytes) : undefined;
}
