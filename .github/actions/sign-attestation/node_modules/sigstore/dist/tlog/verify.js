"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyTLogEntries = void 0;
const error_1 = require("../error");
const util_1 = require("../util");
const TLOG_MISMATCH_ERROR_MSG = 'bundle content and tlog entry do not match';
// Verifies that all of the tlog entries in the given bundle.
function verifyTLogEntries(bundle, tlogKeys) {
    var _a, _b, _c;
    // Extract the signing cert bytes if available
    let signingCert;
    if (((_b = (_a = bundle.verificationMaterial) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.$case) === 'x509CertificateChain') {
        signingCert =
            bundle.verificationMaterial.content.x509CertificateChain.certificates[0]
                .rawBytes;
    }
    // Iterate over the tlog entries and verify each one
    (_c = bundle.verificationData) === null || _c === void 0 ? void 0 : _c.tlogEntries.forEach((entry) => {
        verifyTLogBody(entry, bundle);
        verifyTLogSET(entry, tlogKeys);
        // If there is no signing certificate, we can't verify the integrated time
        if (signingCert) {
            verifyTLogIntegratedTime(entry, signingCert);
        }
    });
}
exports.verifyTLogEntries = verifyTLogEntries;
// Verfifies the SET for the given entry using the provided keys.
function verifyTLogSET(entry, tlogKeys) {
    var _a;
    // Re-create the original Rekor verification payload
    const payload = toVerificationPayload(entry);
    // Canonicalize the payload and turn into a buffer for verification
    const data = Buffer.from(util_1.json.canonicalize(payload), 'utf8');
    // Find the public key for the transaction log which generated the SET
    const tlogKey = tlogKeys[payload.logID];
    if (!tlogKey) {
        throw new error_1.VerificationError('no key found for logID: ' + payload.logID);
    }
    // Extract the SET from the tlog entry
    const signature = (_a = entry.inclusionPromise) === null || _a === void 0 ? void 0 : _a.signedEntryTimestamp;
    if (!signature || signature.length === 0) {
        throw new error_1.InvalidBundleError('no SET found in bundle');
    }
    if (!util_1.crypto.verifyBlob(data, tlogKey, signature)) {
        throw new error_1.VerificationError('transparency log SET verification failed');
    }
}
// Checks that the tlog integrated time is within the certificate's validity
// period.
function verifyTLogIntegratedTime(entry, signingCert) {
    const x509Cert = util_1.x509.parseCertificate(signingCert);
    const integratedTime = new Date(Number(entry.integratedTime) * 1000);
    if (integratedTime > x509Cert.validTo) {
        throw new error_1.VerificationError('tlog integrated time is after certificate expiration');
    }
    if (integratedTime < x509Cert.validFrom) {
        throw new error_1.VerificationError('tlog integrated time is before certificate issuance');
    }
}
// Compare the given intoto tlog entry to the given bundle
function verifyTLogBody(entry, bundle) {
    if (!entry.kindVersion) {
        throw new error_1.InvalidBundleError('no kindVersion found in bundle');
    }
    const { kind, version } = entry.kindVersion;
    const body = JSON.parse(entry.canonicalizedBody.toString('utf8'));
    if (kind !== body.kind || version !== body.apiVersion) {
        throw new error_1.VerificationError(TLOG_MISMATCH_ERROR_MSG);
    }
    switch (body.kind) {
        case 'intoto':
            verifyIntotoTLogBody(body, bundle);
            break;
        case 'hashedrekord':
            verifyHashedRekordTLogBody(body, bundle);
            break;
        default:
            throw new error_1.UnsupportedVersionError(`unsupported kind in tlog entry: ${kind}`);
    }
}
// Compare the given intoto tlog entry to the given bundle
function verifyIntotoTLogBody(tlogEntry, bundle) {
    var _a, _b;
    if (((_a = bundle.content) === null || _a === void 0 ? void 0 : _a.$case) !== 'dsseEnvelope') {
        throw new error_1.UnsupportedVersionError(`unsupported bundle content: ${((_b = bundle.content) === null || _b === void 0 ? void 0 : _b.$case) || 'unknown'}`);
    }
    const dsse = bundle.content.dsseEnvelope;
    switch (tlogEntry.apiVersion) {
        case '0.0.2':
            verifyIntoto002TLogBody(tlogEntry, dsse);
            break;
        default:
            throw new error_1.UnsupportedVersionError(`unsupported intoto version: ${tlogEntry.apiVersion}`);
    }
}
// Compare the given hashedrekord tlog entry to the given bundle
function verifyHashedRekordTLogBody(tlogEntry, bundle) {
    var _a, _b;
    if (((_a = bundle.content) === null || _a === void 0 ? void 0 : _a.$case) !== 'messageSignature') {
        throw new error_1.UnsupportedVersionError(`unsupported bundle content: ${((_b = bundle.content) === null || _b === void 0 ? void 0 : _b.$case) || 'unknown'}`);
    }
    const messageSignature = bundle.content.messageSignature;
    switch (tlogEntry.apiVersion) {
        case '0.0.1':
            verifyHashedrekor001TLogBody(tlogEntry, messageSignature);
            break;
        default:
            throw new error_1.UnsupportedVersionError(`unsupported hashedrekord version: ${tlogEntry.apiVersion}`);
    }
}
// Compare the given intoto v0.0.2 tlog entry to the given DSSE envelope.
function verifyIntoto002TLogBody(tlogEntry, dsse) {
    var _a, _b;
    // Collect all of the signatures from the DSSE envelope
    // Turns them into base64-encoded strings for comparison
    const dsseSigs = dsse.signatures.map((signature) => signature.sig.toString('base64'));
    // Collect all of the signatures from the tlog entry
    // Remember that tlog signastures are double base64-encoded
    const tlogSigs = (_a = tlogEntry.spec.content.envelope) === null || _a === void 0 ? void 0 : _a.signatures.map((signature) => (signature.sig ? util_1.encoding.base64Decode(signature.sig) : ''));
    // Ensure the bundle's DSSE and the tlog entry contain the same number of signatures
    if (dsseSigs.length !== (tlogSigs === null || tlogSigs === void 0 ? void 0 : tlogSigs.length)) {
        throw new error_1.VerificationError(TLOG_MISMATCH_ERROR_MSG);
    }
    // Ensure that every signature in the bundle's DSSE is present in the tlog entry
    if (!dsseSigs.every((dsseSig) => tlogSigs.includes(dsseSig))) {
        throw new error_1.VerificationError(TLOG_MISMATCH_ERROR_MSG);
    }
    // Ensure the digest of the bundle's DSSE payload matches the digest in the
    // tlog entry
    const dssePayloadHash = util_1.crypto.hash(dsse.payload).toString('hex');
    if (dssePayloadHash !== ((_b = tlogEntry.spec.content.payloadHash) === null || _b === void 0 ? void 0 : _b.value)) {
        throw new error_1.VerificationError(TLOG_MISMATCH_ERROR_MSG);
    }
}
// Compare the given hashedrekord v0.0.1 tlog entry to the given message
// signature
function verifyHashedrekor001TLogBody(tlogEntry, messageSignature) {
    var _a, _b;
    // Ensure that the bundles message signature matches the tlog entry
    const msgSig = messageSignature.signature.toString('base64');
    const tlogSig = tlogEntry.spec.signature.content;
    if (msgSig !== tlogSig) {
        throw new error_1.VerificationError(TLOG_MISMATCH_ERROR_MSG);
    }
    // Ensure that the bundle's message digest matches the tlog entry
    const msgDigest = (_a = messageSignature.messageDigest) === null || _a === void 0 ? void 0 : _a.digest.toString('hex');
    const tlogDigest = (_b = tlogEntry.spec.data.hash) === null || _b === void 0 ? void 0 : _b.value;
    if (msgDigest !== tlogDigest) {
        throw new error_1.VerificationError(TLOG_MISMATCH_ERROR_MSG);
    }
}
// Returns a properly formatted "VerificationPayload" for one of the
// transaction log entires in the given bundle which can be used for SET
// verification.
function toVerificationPayload(entry) {
    // Rekor metadata
    const { integratedTime, logIndex, logId, canonicalizedBody } = entry;
    if (!logId) {
        throw new error_1.InvalidBundleError('no logId found in bundle');
    }
    return {
        body: canonicalizedBody.toString('base64'),
        integratedTime: Number(integratedTime),
        logIndex: Number(logIndex),
        logID: logId.keyId.toString('hex'),
    };
}
